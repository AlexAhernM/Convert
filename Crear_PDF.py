
import customtkinter as ctk
import ezdxf
import matplotlib.pyplot as plt

distancias = {
    (0, 50): (500,6),
    (51,100):(1000,5),
    (101, 150): (1500,4),
    (150, 300): (2000,3),
    (301, float('inf')): (2500,2),
    }

def crear_pdf(ruta_archivo_salida_dxf):
    try:
        doc = ezdxf.readfile(ruta_archivo_salida_dxf)
    except Exception as e:
        print(f"Error al leer el archivo DXF: {e}")
        return

    msp = doc.modelspace()
    fig, ax = plt.subplots()
    min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'), float('-inf')
    textos_existentes = []

    for entity in msp:
        if entity.dxftype() == 'LINE':
            ax.plot([entity.dxf.start[0], entity.dxf.end[0]], [entity.dxf.start[1], entity.dxf.end[1]], 'k-')

        elif entity.dxftype() == 'CIRCLE':
            circle = plt.Circle((entity.dxf.center[0], entity.dxf.center[1]), entity.dxf.radius, edgecolor='black', facecolor='none')
            ax.add_artist(circle)
            ax.annotate(entity.dxf.layer, (entity.dxf.center[0], entity.dxf.center[1]), textcoords="offset points", xytext=(0, 15), ha='center')

        elif entity.dxftype() == 'POLYLINE':
            x = [v.dxf.location.x for v in entity.vertices]
            y = [v.dxf.location.y for v in entity.vertices]

            if entity.has_xdata('ACAD'):
                xdata = entity.get_xdata('ACAD')
                if any(code == 1000 and value == 'CIRCULO' for code, value in xdata):
                    ax.fill(x[:-1], y[:-1], color='black')
            else:
                ax.plot(x, y, 'k-', lw=0.3)
                min_x, min_y = min(min_x, min(x)), min(min_y, min(y))
                max_x, max_y = max(max_x, max(x)), max(max_y, max(y))

        elif entity.dxftype() == 'POINT':
            ax.plot(entity.dxf.location[0], entity.dxf.location[1], 'ko')

    escala = f"1:{int((max_x - min_x) / 100)}"
    escala_num = int(escala.split(":")[1]) if ":" in escala else 100

    dialog = ctk.CTkInputDialog(text="Ingrese un nombre al dibujo", title="Proyecto")
    titulo = dialog.get_input() or "Image Generated by Ambylog's Geo Converter"

    resultado = next((valor for rango, valor in distancias.items() if rango[0] <= escala_num <= rango[1]), None)
    if resultado:
        distancia_minima, fontsize = resultado
    else:
        distancia_minima, fontsize = 1000, 5  # valores por defecto

    ax.set_aspect('equal')
    ax.axis('off')

    fig.subplots_adjust(bottom=0.2)
    ax_table = fig.add_axes([0.1, 0.02, 0.8, 0.1])
    ax_table.axis('off')
    table = ax_table.table(cellText=[[f"Proyecto: {titulo}"], [f"Escala: {escala}"]], loc='center')
    table.set_fontsize(6)
    table.scale(1, 1.5)

    for entity in msp:
        if entity.dxftype() == 'POLYLINE' and entity.has_xdata('ACAD'):
            x = [v.dxf.location.x for v in entity.vertices]
            y = [v.dxf.location.y for v in entity.vertices]
            x_texto = sum(x[:-1]) / len(x[:-1])
            y_texto = sum(y[:-1]) / len(y[:-1])

            if all(((x_texto - tx) ** 2 + (y_texto - ty) ** 2) ** 0.5 >= distancia_minima for tx, ty in textos_existentes):
                ax.annotate(entity.dxf.layer, (x_texto, y_texto), ha='center', fontname='Arial', xytext=(0, 1), fontsize=fontsize, textcoords='offset points')
                textos_existentes.append((x_texto, y_texto))
