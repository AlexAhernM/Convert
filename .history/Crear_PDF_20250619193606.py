
import customtkinter as ctk
import ezdxf
import matplotlib.pyplot as plt



def crear_pdf(ruta_archivo_salida_dxf):
    # Abrir el archivo DXF
    doc = ezdxf.readfile(ruta_archivo_salida_dxf)
    msp = doc.modelspace()
    textos_existentes = []
    fig, ax = plt.subplots()
    min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'), float('-inf')
    
    for entity in msp:
        if entity.dxftype() == 'LINE':
            ax.plot([entity.dxf.start[0], entity.dxf.end[0]], [entity.dxf.start[1], entity.dxf.end[1]], 'k-')
            
        elif entity.dxftype() == 'CIRCLE':
            circle = plt.Circle((entity.dxf.center[0], entity.dxf.center[1]), entity.dxf.radius, edgecolor='black', facecolor='none')
            ax.add_artist(circle)
            ax.annotate(entity.dxf.layer, (entity.dxf.center[0], entity.dxf.center[1]), textcoords="offset points", xytext=(0, 15), ha='center')
        
        elif entity.dxftype() == 'POLYLINE':
            x = [v.dxf.location.x for v in entity.vertices]
            y = [v.dxf.location.y for v in entity.vertices]
            x_texto = sum(x[:-1])/len(x[:-1])
            y_texto = sum(y[:-1])/len(y[:-1])
            
            if entity.has_xdata('ACAD'):
                xdata = entity.get_xdata('ACAD')
                for code, value in xdata:
                    if code == 1000 and value == 'CIRCULO':
                        # Es un círculo creado en el script TRANFORMA
                        ax.fill(x[:-1], y[:-1], color='black')
                        cerca_de_texto = False
                        for texto in textos_existentes:
                            distancia = ((x_texto - texto[0]) ** 2 + (y_texto - texto[1]) ** 2) ** 0.5
                            if distancia < 1500:  # ajustar distancia s/ necesario
                                cerca_de_texto = True
                                break
                        if not cerca_de_texto:        
                            ax.annotate(entity.dxf.layer, (x_texto, y_texto), ha='center',
                                    fontsize = 3, fontname = 'Arial',textcoords="offset points", xytext=(0, 2) )
                            textos_existentes.append((x_texto, y_texto))
                        break              
        
            else:
                # No es un círculo creado en el script TRANFORMA
                x = [v.dxf.location.x for v in entity.vertices]
                y = [v.dxf.location.y for v in entity.vertices]
                ax.plot(x, y, 'k-', lw=0.5)
                #ax.annotate(entity.dxf.layer, (x[0], y[0]), textcoords="offset points", xytext=(0, 5), ha='center', fontsize=6)
                
                min_x, min_y = min(min_x, min(x)), min(min_y, min(y))
                max_x, max_y = max(max_x, max(x)), max(max_y, max(y))

                
        elif entity.dxftype() == 'POINT':
            ax.plot(entity.dxf.location[0], entity.dxf.location[1], 'ko')
            
        
    escala = f"1:{int((max_x - min_x) / 100)}"
    dialog = ctk.CTkInputDialog(text="Ingrese un nombre al dibujo", title="Proyecto")
    titulo = dialog.get_input()
    if titulo is None or titulo == "":
        titulo = "Image Generated by Ambylog's Geo Converter"
    ax.set_aspect('equal')
    ax.axis('off')
    
    # Agregar tabla con escala y título
    fig.subplots_adjust(bottom=0.2)
    ax_table = fig.add_axes([0.1, 0.02, 0.8, 0.1])
    ax_table.axis('off')
    table = ax_table.table(cellText=[[f"Proyecto: {titulo}"], [f"Escala: {escala}"]], loc='center')
    table.set_fontsize(6)
    table.scale(1, 1.5)

    # Guarda el archivo PDF