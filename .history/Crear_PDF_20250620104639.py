
import customtkinter as ctk
import ezdxf
import matplotlib.pyplot as plt

distancias = {
    (0, 50): (500,5),
    (51,100):(1000,4),
    (101, 150): (1500,3),
    (150, 200): (2000,2),
    (201, float('inf')): (2500,1),
    }

def crear_pdf(ruta_archivo_salida_dxf):
    # Abrir el archivo DXF
    doc = ezdxf.readfile(ruta_archivo_salida_dxf)
    msp = doc.modelspace()
    textos_existentes = []
    fig, ax = plt.subplots()
    min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'), float('-inf')
    
    for entity in msp:
        if entity.dxftype() == 'LINE':
            ax.plot([entity.dxf.start[0], entity.dxf.end[0]], [entity.dxf.start[1], entity.dxf.end[1]], 'k-')
            
        elif entity.dxftype() == 'CIRCLE':
            circle = plt.Circle((entity.dxf.center[0], entity.dxf.center[1]), entity.dxf.radius, edgecolor='black', facecolor='none')
            ax.add_artist(circle)
            ax.annotate(entity.dxf.layer, (entity.dxf.center[0], entity.dxf.center[1]), textcoords="offset points", xytext=(0, 15), ha='center')
        
        elif entity.dxftype() == 'POLYLINE':
            x = [v.dxf.location.x for v in entity.vertices]
            y = [v.dxf.location.y for v in entity.vertices]
            x_texto = sum(x[:-1])/len(x[:-1])
            y_texto = sum(y[:-1])/len(y[:-1])
            
            if entity.has_xdata('ACAD'):
                xdata = entity.get_xdata('ACAD')
                for code, value in xdata:
                    if code == 1000 and value == 'CIRCULO':
                        # Es un círculo creado en el script TRANFORMA
                        ax.fill(x[:-1], y[:-1], color='black')
                               
        
            else:
                # No es un círculo creado en el script TRANFORMA
                x = [v.dxf.location.x for v in entity.vertices]
                y = [v.dxf.location.y for v in entity.vertices]
                ax.plot(x, y, 'k-', lw=0.5)
                #ax.annotate(entity.dxf.layer, (x[0], y[0]), textcoords="offset points", xytext=(0, 5), ha='center', fontsize=6)
                
                min_x, min_y = min(min_x, min(x)), min(min_y, min(y))
                max_x, max_y = max(max_x, max(x)), max(max_y, max(y))

                
        elif entity.dxftype() == 'POINT':
            ax.plot(entity.dxf.location[0], entity.dxf.location[1], 'ko')
            
        
    escala = f"1:{int((max_x - min_x) / 100)}"
    dialog = ctk.CTkInputDialog(text="Ingrese un nombre al dibujo", title="Proyecto")
    titulo = dialog.get_input()
    if titulo is None or titulo == "":
        titulo = "Image Generated by Ambylog's Geo Converter"
    ax.set_aspect('equal')
    ax.axis('off')
    
    escala_num = int(escala.split(":")[1])
    resultado = next((valor for rango, valor in distancias.items() if rango[0] <= escala_num <= rango[1]), None)
    if resultado:
        distancia_minima = resultado[0]
        fontsize = resultado[1]
    
    # Agregar tabla con escala y título
    fig.subplots_adjust(bottom=0.2)
    ax_table = fig.add_axes([0.1, 0.02, 0.8, 0.1])
    ax_table.axis('off')
    table = ax_table.table(cellText=[[f"Proyecto: {titulo}"], [f"Escala: {escala}"]], loc='center')
    table.set_fontsize(6)
    table.scale(1, 1.5)

    textos_existentes = []
    # Colocar los textos con la distancia y fuentes  ajustadas
    for entity in msp:
    
        if entity.dxftype() == 'POLYLINE' and entity.has_xdata('ACAD'):         
            
            x = [v.dxf.location.x for v in entity.vertices]
            y = [v.dxf.location.y for v in entity.vertices]
            x_texto = sum(x[:-1])/len(x[:-1])
            y_texto = sum(y[:-1])/len(y[:-1])
            
            cerca_de_texto = False
            for texto in textos_existentes:
                distancia = ((x_texto - texto[0]) ** 2 + (y_texto - texto[1]) ** 2) ** 0.5
                if distancia < 1000:
                    cerca_de_texto = True
                    break
            if not cerca_de_texto:
                ax.annotate(entity.dxf.layer, (x_texto, y_texto), ha='center',fontname='Arial', xytext=(0, 1), 
                            textcoords='offset points')
                textos_existentes.append((x_texto, y_texto))
                break

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    